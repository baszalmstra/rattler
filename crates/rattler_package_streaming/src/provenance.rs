use itertools::Itertools;
use rattler_conda_types::{package::ArchiveIdentifier, RepoDataRecord};
use rattler_digest::{parse_digest_from_hex, Md5, Md5Hash, Sha256, Sha256Hash};
use serde_with::{DeserializeFromStr, SerializeDisplay};
use std::str::FromStr;
use std::{fmt, ops::Deref};
use thiserror::Error;
use url::Url;

/// A struct that describes the origin of a package as well as the hashes of the package archive to
/// be able verify its integrity.
#[derive(Debug, Clone)]
pub struct PackageProvenance {
    /// A Url that describes the origin of the package. This can be an HTTP(s) url or a `file://`
    /// url.
    pub url: Url,

    /// An identifier for a package that includes the name, version, build_string and archive type.
    /// This is *not* a unique identifier because the same package might be stored in multiple
    /// different channels with different content.
    pub identifier: ArchiveIdentifier,

    /// A combination of different hashes of the package archive.
    pub integrity: ProvenanceIntegrity,
}

impl PackageProvenance {
    /// Returns true if this provenance refers to a package on disk.
    pub fn is_local(&self) -> bool {
        self.url.scheme() == "file"
    }

    /// Returns true if this provenance refers to a package on a remote server.
    pub fn is_remote(&self) -> bool {
        self.url.scheme().starts_with("http")
    }
}

/// Represents multiple digests of the same data generated by different algorithms.
#[derive(Debug, Clone)]
pub struct ProvenanceIntegrity(Vec<Hash>);

impl ProvenanceIntegrity {
    /// Returns the best hash for verifying the integrity of the package archive.
    pub fn get_best_hash(&self) -> Option<&Hash> {
        self.first()
    }
}

impl FromIterator<Hash> for ProvenanceIntegrity {
    fn from_iter<T: IntoIterator<Item = Hash>>(iter: T) -> Self {
        Self(iter.into_iter().sorted().collect())
    }
}

/// Represents a hash function and a digest.
///
/// I would prefer to get rid of this struct and just use [`cacache::Integrity`] but that doesnt
/// support Md5 (for good reasons). Unfortunately there are still lots of packages in the conda
/// ecosystem that only provide Md5 hashes.
#[derive(Debug, Clone, Ord, PartialOrd, Eq, PartialEq, SerializeDisplay, DeserializeFromStr)]
pub enum Hash {
    /// A Sha256 hash
    Sha256(Sha256Hash),

    /// An Md5 hash
    Md5(Md5Hash),
}

impl fmt::Display for Hash {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Hash::Sha256(hash) => write!(f, "sha256-{hash:x}"),
            Hash::Md5(hash) => write!(f, "md5-{hash:x}"),
        }
    }
}

#[derive(Debug, Error)]
pub enum ParseHashError {
    #[error("{0} is not a valid {1} hash")]
    InvalidHash(String, String),

    #[error("unsupported hash algorithm in {0}")]
    UnsupportedAlgorithm(String),

    #[error("missing hash algorithm in {0}")]
    MissingAlgorithm(String),
}

impl FromStr for Hash {
    type Err = ParseHashError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let (algo, hash) = s
            .trim()
            .split_once('-')
            .ok_or_else(|| ParseHashError::MissingAlgorithm(s.to_string()))?;
        match algo {
            "sha256" => Ok(Hash::Sha256(
                parse_digest_from_hex::<Sha256>(hash).ok_or_else(|| {
                    ParseHashError::InvalidHash(hash.to_string(), algo.to_string())
                })?,
            )),
            "md5" => Ok(Hash::Md5(parse_digest_from_hex::<Md5>(hash).ok_or_else(
                || ParseHashError::InvalidHash(hash.to_string(), algo.to_string()),
            )?)),
            _ => Err(ParseHashError::UnsupportedAlgorithm(s.to_string())),
        }
    }
}

impl<'a> From<&'a RepoDataRecord> for ProvenanceIntegrity {
    fn from(record: &'a RepoDataRecord) -> Self {
        let sha256 = record.package_record.sha256.map(|x| Hash::Sha256(x));
        let md5 = record.package_record.md5.map(|x| Hash::Md5(x));
        Self::from_iter(sha256.into_iter().chain(md5.into_iter()))
    }
}

impl Deref for ProvenanceIntegrity {
    type Target = Vec<Hash>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl fmt::Display for ProvenanceIntegrity {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.iter().format(", "))
    }
}

#[derive(Debug, Error)]
pub enum ProvenanceError {
    #[error("invalid archive identifier in url")]
    InvalidIdentifier,

    #[error("no hashes found in package record")]
    MissingHash,
}

impl<'a> TryFrom<&'a RepoDataRecord> for PackageProvenance {
    type Error = ProvenanceError;

    fn try_from(record: &'a RepoDataRecord) -> Result<Self, ProvenanceError> {
        let integrity = ProvenanceIntegrity::from(record);
        if integrity.is_empty() {
            return Err(ProvenanceError::MissingHash);
        }

        Ok(Self {
            url: record.url.clone(),
            identifier: ArchiveIdentifier::try_from_url(&record.url)
                .ok_or(ProvenanceError::InvalidIdentifier)?,
            integrity,
        })
    }
}
